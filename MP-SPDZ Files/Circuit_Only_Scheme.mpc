# Run all commands from the MP-SPDZ folder
# Run ./compile.py Circuit_Only_Scheme
# Run P0: ./atlas-party.x Circuit_Only_Scheme -p 0 -N 3 -IF ../PycharmProjects/MasterThesis/Client/MP-SPDZ\ Inputs/Circuit_Only_Input -OF ../PycharmProjects/MasterThesis/Client/MP-SPDZ\ Outputs/Circuit_Only_Output
# Run P1: ./atlas-party.x Circuit_Only_Scheme -p 1 -N 3 -IF ../PycharmProjects/MasterThesis/Server/MP-SPDZ\ Inputs/Circuit_Only_Input
# Run P2: ./atlas-party.x Circuit_Only_Scheme -p 2 -N 3


from oram import OptimalORAM


def not_in(target, iterable, size):
    counter = sint(0)
    for element in range(size):
        counter += (target == iterable[element])

    return (counter == 0)

def search_indexing_oram():
    size_counter = sint(0)
    pointers = OptimalORAM(number_of_files + 1)
    for i in range(size_of_search_queries):
        search_query = search_queries[i]

        for j in range(number_of_indices):
            index = inverted_index_matrix[j][0]

            match = (search_query == index)

            for l in range(1, index_length + size_of_set_of_pointers):
                pointer = inverted_index_matrix[j][l]

                pointers[size_counter] = match * pointer * not_in(pointer, pointers, number_of_files + 1)
                size_counter += (pointers[size_counter] != 0)

    return pointers

def search_indexing():
    counter = 0
    pointers = sint.Array(number_of_indices * size_of_set_of_pointers * size_of_search_queries)
    for i in range(size_of_search_queries):
        search_query = search_queries[i]

        for j in range(number_of_indices):
            index = inverted_index_matrix[j][0]

            match = (search_query == index)


            for l in range(1, index_length + size_of_set_of_pointers):
                pointer = inverted_index_matrix[j][l]
                pointers[counter * size_of_set_of_pointers + (l - 1)] = match * pointer

            counter += 1



    return pointers

def input_is_set_retrieve_files_oram(pointers):   # Takes 182.23 sec with just one file...
    size_counter = sint(0)
    files = OptimalORAM(number_of_files * file_size_length_upper_bound)
    for i in range(number_of_files):
        file_signature = database[i][0]

        for j in range(number_of_files):
            pointer = pointers[j]

            match = (pointer == file_signature)

            for l in range(1, file_signature_length + file_size_length_upper_bound):
                character = database[j][l]
                files[size_counter * file_size_length_upper_bound + (l - 1)] = match * character

            size_counter += match

    return files

def input_is_set_retrieve_files(pointers):   # Takes 0.1631 sec with just one file :)
    counter = 0
    files = sint.Array(number_of_files * number_of_files * file_size_length_upper_bound)
    for i in range(number_of_files):
        file_signature = database[i][0]

        for j in range(number_of_files):
            pointer = pointers[j]

            match = (pointer == file_signature)

            for l in range(1, file_signature_length + file_size_length_upper_bound):
                character = database[j][l]
                files.assign(match * character, counter * file_size_length_upper_bound + (l - 1))

            counter += 1

    return files

def retrieve_files(pointers):   # Takes 0.133 sec with just one file, huge memory requirements...
    counter = 0
    files = sint.Array(number_of_files * file_size_length_upper_bound * number_of_indices * size_of_set_of_pointers * size_of_search_queries)
    for i in range(number_of_indices * size_of_set_of_pointers * size_of_search_queries):
        pointer = pointers[i]

        for j in range(number_of_files):
            file_signature = database[j][0]

            match = (pointer == file_signature)

            for l in range(1, file_signature_length + file_size_length_upper_bound):
                character = database[j][l]
                files.assign(match * character, counter * file_size_length_upper_bound + (l - 1))

            counter += 1

    return files

# Results: Time = 0.140 seconds, Data sent = 15.9 MB, for one file and one query
def test_searching_no_oram_retrieval_no_oram():
    # Pointers is an array of size number_of_files * size_of_set_of_pointers * size_of_search_queries
    pointers = search_indexing()

    # Files is an array of size number_of_files * file_size_length_upper_bound * number_of_indices * size_of_set_of_pointers * size_of_search_queries
    files = retrieve_files(pointers)

# Results: Time = 0.163 seconds, Global data sent = 9.3 MB, for one file and one query
def test_searching_oram_retrival_no_oram():
    # Pointers is a set of size number_of_files
    pointers = search_indexing_oram()

    # Files is an array of size number_of_files * number_of_files * file_size_length_upper_bound
    files = input_is_set_retrieve_files(pointers)

#   Results: Time = 172.337 seconds, Global data sent = 10596.8 MB, for one file and one query
def test_searching_oram_retrival_oram():
    # Pointers is a set of size number_of_files
    pointers = search_indexing_oram()

    # Files is an array of size number_of_files * file_size_length_upper_bound
    files = input_is_set_retrieve_files_oram(pointers)

# Defining global variables
size_of_search_queries = 1

index_length = 1
number_of_indices = 21
size_of_set_of_pointers = 1

file_signature_length = 1
number_of_files = 1
file_size_length_upper_bound = 6000

# Inputs from parties
search_queries = sint.input_tensor_from(0, [size_of_search_queries])
inverted_index_matrix = sint.input_tensor_from(1, [number_of_indices, index_length + size_of_set_of_pointers])
database = sint.input_tensor_from(1, [number_of_files, file_signature_length + file_size_length_upper_bound])

# Testing different combinations of approaches
#test_searching_oram_retrival_oram()
test_searching_no_oram_retrieval_no_oram()
#test_searching_oram_retrival_no_oram()
